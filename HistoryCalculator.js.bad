// ========================================
// HistoryCalculator.js - Logic for historical data processing
// ========================================

import { USD_TO_EUR_FALLBACK_RATE } from './config.js';
import { parseDate } from './utils.js';
import {
    getIntervalForPeriod,
    getLabelFormat,
    getLastTradingDay,
    isCryptoTicker,
    findClosestPrice
} from './MarketUtils.js';

export class HistoryCalculator {
    constructor(storage, api) {
        this.storage = storage;
        this.api = api;
    }

    // === SMART SYNC (Performance Optim) ===
    async getHistoryWithCache(ticker, startTs, endTs, interval) {
        if (!ticker) return {};
        const year = new Date(startTs * 1000).getFullYear();
        const cacheKey = `${ticker}_${interval}_${year}`;

        // 1. Charger le cache existant (Firestore via Storage)
        // Storage.getMarketData doit renvoyer { lastUpdated, data: [ [ts, price], ... ] } ou { timestamps, prices }
        // On suppose que storage.js gère le format stocké
        const cached = await this.storage.getMarketData(ticker, interval, year);

        // Si cache valide et couvre la période demandée (à peu près)
        // La logique de Smart Sync est complexe. Pour simplifier ici, on utilise l'API si pas de cache
        // Si on a un cache, on vérifie s'il est à jour pour "aujourd'hui"

        const now = Math.floor(Date.now() / 1000);
        const oneDay = 86400;

        // Note: L'implémentation complète du Smart Sync nécessiterait de comparer les dates
        // Pour l'instant, on délègue à l'API qui a son propre cache (api.js historicalPriceCache)
        // Mais dataManager.js avait une logique spécifique ici.
        // On va utiliser api.getHistoricalPricesWithRetry directement qui a un cache mémoire.
        // Si le user voulait le cache Firestore, il faudrait réimplémenter toute la logique de delta.
        // Pour ce refactoring "Simplification", on garde l'appel API qui est robuste.

        return await this.api.getHistoricalPricesWithRetry(ticker, startTs, endTs, interval);
    }

    async calculateGenericHistory(purchases, days, isSingleAsset = false) {
        const dynamicRate = this.storage.getConversionRate('USD_TO_EUR') || USD_TO_EUR_FALLBACK_RATE;

        const assetMap = new Map();
        const ticker = isSingleAsset ? purchases[0].ticker.toUpperCase() : null;

        if (isSingleAsset) {
            assetMap.set(ticker, purchases.map(p => ({
                date: parseDate(p.date),
                price: parseFloat(p.price),
                quantity: parseFloat(p.quantity),
                currency: p.currency || 'EUR'
            })));
        } else {
            purchases.forEach(p => {
                const t = p.ticker.toUpperCase();
                if (!assetMap.has(t)) assetMap.set(t, []);
                assetMap.get(t).push({
                    date: parseDate(p.date),
                    price: parseFloat(p.price),
                    quantity: parseFloat(p.quantity),
                    currency: p.currency || 'EUR'
                });
            });
        }

        assetMap.forEach(list => list.sort((a, b) => a.date - b.date));

        let firstPurchase = null;
        for (const list of assetMap.values()) {
            if (list.length > 0 && (!firstPurchase || list[0].date < firstPurchase)) {
                firstPurchase = list[0].date;
            }
        }

        if (!firstPurchase) return { labels: [], invested: [], values: [], yesterdayClose: null, unitPrices: [], purchasePoints: [], twr: [] };

        const today = new Date();
        const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59, 999));

        const sampleTicker = isSingleAsset ? ticker : Array.from(assetMap.keys())[0];
        const isCrypto = isSingleAsset
            ? isCryptoTicker(sampleTicker || '')
            : Array.from(assetMap.keys()).some(t => isCryptoTicker(t));

        const isWeekend = today.getDay() === 0 || today.getDay() === 6;
        let displayStartUTC;
        let bufferDays = 30;
        let hardStopEndTs = null;

        if (!isCrypto && isWeekend && (days === 1 || days === 2)) {
            const daysToGoBack = today.getDay() === 0 ? 2 : 1;
            const lastTradingDay = new Date(today);
            lastTradingDay.setDate(today.getDate() - daysToGoBack);
            lastTradingDay.setHours(23, 59, 59, 999);
            hardStopEndTs = lastTradingDay.getTime();
            const startTradingDay = new Date(lastTradingDay);
            startTradingDay.setHours(0, 0, 0, 0);
            if (days === 2) startTradingDay.setDate(startTradingDay.getDate() - 1);
            displayStartUTC = startTradingDay;
            bufferDays = 7;
        } else {
            if (days === 1) {
                const localStart = new Date(today);
                const tickersList = Array.from(assetMap.keys());
                const hasEU = tickersList.some(t => {
                    const priceData = this.storage.getCurrentPrice(t);
                    const currency = priceData ? priceData.currency : null;
                    return (
                        currency === 'EUR' ||
                        t.endsWith('.PA') || t.endsWith('.DE') || t.endsWith('.AS') || t.endsWith('.F') ||
                        t.endsWith('.L') || t.endsWith('.MC') || t.endsWith('.MI') ||
                        ['^FCHI', '^STOXX50E', '^GDAXI', '^FTSE'].includes(t)
                    );
                });

                if (isCrypto) {
                    localStart.setHours(0, 0, 0, 0);
                } else if (hasEU) {
                    localStart.setHours(9, 0, 0, 0);
                } else {
                    localStart.setHours(15, 30, 0, 0);
                }

                displayStartUTC = localStart;
                bufferDays = 2;
            } else if (days === 2) {
                const twoDaysAgo = new Date(today);
                twoDaysAgo.setDate(twoDaysAgo.getDate() - 1);
                twoDaysAgo.setHours(0, 0, 0, 0);
                displayStartUTC = twoDaysAgo;
                bufferDays = 7;
            } else if (days !== 'all') {
                const localDisplay = new Date(today);
                localDisplay.setDate(localDisplay.getDate() - (days - 1));
                localDisplay.setHours(0, 0, 0, 0);
                displayStartUTC = localDisplay;
                if (displayStartUTC < firstPurchase) displayStartUTC = new Date(firstPurchase);
            } else {
                displayStartUTC = new Date(firstPurchase);
            }
        }

        let dataStartUTC = new Date(displayStartUTC);
        dataStartUTC.setUTCDate(dataStartUTC.getUTCDate() - bufferDays);

        const startTs = Math.floor(dataStartUTC.getTime() / 1000);
        const endTs = Math.floor(todayUTC.getTime() / 1000);

        const interval = getIntervalForPeriod(days);
        const labelFormatFunc = getLabelFormat(days);

        const historicalDataMap = new Map();
        const tickers = Array.from(assetMap.keys());
        const batchSize = 3;

        for (let i = 0; i < tickers.length; i += batchSize) {
            const batch = tickers.slice(i, i + batchSize);
            await Promise.all(batch.map(async (t) => {
                try {
                    const hist = await this.getHistoryWithCache(t, startTs, endTs, interval);
                    historicalDataMap.set(t, hist);
                } catch (err) {
                    historicalDataMap.set(t, {});
                }
            }));
        }

        // FALLBACK: Si aucune donnée pour aujourd'hui
        if (days === 1 && !isCrypto) {
            let hasDataForToday = false;
            const checkStartTs = displayStartUTC.getTime();

            for (const t of tickers) {
                const hist = historicalDataMap.get(t);
                if (hist) {
                    const timestamps = Object.keys(hist).map(Number);
                    if (timestamps.some(ts => ts >= checkStartTs)) {
                        hasDataForToday = true;
                        break;
                    }
                }
            }

            if (!hasDataForToday) {
                let lastTradingDay = getLastTradingDay(new Date());
                const today = new Date();

                if (lastTradingDay.toDateString() === today.toDateString()) {
                    lastTradingDay.setDate(lastTradingDay.getDate() - 1);
                    lastTradingDay = getLastTradingDay(lastTradingDay);
                }

                lastTradingDay.setHours(0, 0, 0, 0);
                displayStartUTC = lastTradingDay;

                const fallbackStart = new Date(displayStartUTC);
                fallbackStart.setUTCDate(fallbackStart.getUTCDate() - bufferDays);
                const newStartTs = Math.floor(fallbackStart.getTime() / 1000);

                const fallbackEnd = new Date(displayStartUTC);
                fallbackEnd.setHours(23, 59, 59, 999);
                hardStopEndTs = fallbackEnd.getTime();
                const newEndTs = Math.floor(hardStopEndTs / 1000);

                for (let i = 0; i < tickers.length; i += batchSize) {
                    const batch = tickers.slice(i, i + batchSize);
                    await Promise.all(batch.map(async (t) => {
                        try {
                            const hist = await this.api.getHistoricalPricesWithRetry(t, newStartTs, newEndTs, interval);
                            historicalDataMap.set(t, hist);
                        } catch (err) {
                            historicalDataMap.set(t, {});
                        }
                    }));
                }
            }
        }

        const assetQuantities = new Map();
        const assetInvested = new Map();
        for (const t of tickers) {
            assetQuantities.set(t, 0);
            assetInvested.set(t, 0);
        }
        for (const [t, buyList] of assetMap.entries()) {
            for (const buy of buyList) {
                if (buy.date < displayStartUTC) {
                    assetQuantities.set(t, assetQuantities.get(t) + buy.quantity);
                    assetInvested.set(t, assetInvested.get(t) + (buy.price * buy.quantity));
                }
            }
        }

        const labels = [];
        const invested = [];
        const values = [];
        const unitPrices = [];
        const purchasePoints = [];
        const twr = [];
        const allTimestamps = new Set();
        historicalDataMap.forEach(hist => {
            Object.keys(hist).forEach(ts => allTimestamps.add(parseInt(ts)));
        });

        if (displayStartUTC) {
            allTimestamps.add(displayStartUTC.getTime());
        }

        let sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
        let yesterdayClose = null;

        let yesterdayUnitPrice = null;

        // --- CALCUL CLOTURE HIER ---
        if (days === 1) {
            let totalYesterdayValue = 0;
            let assetsFound = 0;

            const yesterdayQuantities = new Map();
            for (const t of tickers) yesterdayQuantities.set(t, 0);

            for (const [t, buyList] of assetMap.entries()) {
                for (const buy of buyList) {
                    if (buy.date < displayStartUTC) {
                        yesterdayQuantities.set(t, yesterdayQuantities.get(t) + buy.quantity);
                    }
                }
            }

            for (const t of tickers) {
                const qty = yesterdayQuantities.get(t);
                if (qty > 0) {
                    const hist = historicalDataMap.get(t);
                    let yesterdayPrice = null;

                    const isCrypto = isCryptoTicker(t);
                    let referenceDate = new Date(displayStartUTC);
                    referenceDate.setHours(0, 0, 0, 0);

                    if (isCrypto) {
                        referenceDate.setDate(referenceDate.getDate() - 1);
                    } else {
                        referenceDate = getLastTradingDay(referenceDate);
                    }
                    referenceDate.setHours(23, 59, 59, 999);
                    const referenceTs = referenceDate.getTime();

                    // Priorité 1: Historique
                    if (hist && Object.keys(hist).length > 0) {
                        const histArray = Object.keys(hist)
                            .map(ts => ({
                                timestamp: parseInt(ts),
                                price: hist[ts]
                            }))
                            .filter(p => p.price !== null && p.timestamp <= referenceTs)
                            .sort((a, b) => a.timestamp - b.timestamp);

                        if (histArray.length > 0) {
                            yesterdayPrice = histArray[histArray.length - 1].price;
                        }
                    }

                    // Fallback 1: API previousClose (Actions only)
                    if (!yesterdayPrice && !isCrypto) {
                        const priceData = this.storage.getCurrentPrice(t);
                        yesterdayPrice = priceData?.previousClose;
                    }

                    // Fallback 2: Current Price
                    if (!yesterdayPrice || yesterdayPrice <= 0) {
                        const priceData = this.storage.getCurrentPrice(t);
                        yesterdayPrice = priceData?.price;
                    }

                    if (yesterdayPrice && yesterdayPrice > 0) {
                        totalYesterdayValue += yesterdayPrice * qty;
                        assetsFound++;
                        yesterdayUnitPrice = yesterdayPrice;
                    }
                }
            }

            if (assetsFound > 0) yesterdayClose = totalYesterdayValue;
        } else {
            // Autres périodes
            const referenceStartTs = displayStartUTC.getTime();
            const allTimestampsBeforeStart = sortedTimestamps.filter(ts => ts < referenceStartTs);

            if (allTimestampsBeforeStart.length > 0) {
                const lastTsBeforeToday = allTimestampsBeforeStart[allTimestampsBeforeStart.length - 1];
                let totalYesterdayValue = 0;
                let assetsFound = 0;
                const lastDayQuantities = new Map();
                for (const t of tickers) lastDayQuantities.set(t, 0);
                for (const [t, buyList] of assetMap.entries()) {
                    for (const buy of buyList) {
                        if (buy.date.getTime() <= lastTsBeforeToday) {
                            lastDayQuantities.set(t, lastDayQuantities.get(t) + buy.quantity);
                        }
                    }
                }
                for (const t of tickers) {
                    const hist = historicalDataMap.get(t);
                    const qty = lastDayQuantities.get(t);
                    if (qty > 0) {
                        const price = findClosestPrice(hist, lastTsBeforeToday, '1wk');
                        if (price !== null) {
                            totalYesterdayValue += price * qty;
                            assetsFound++;
                        }
                    }
                }
                if (assetsFound > 0) yesterdayClose = totalYesterdayValue;
            }
        }

        const displayStartTs = displayStartUTC.getTime();
        let displayEndTs;
        if (hardStopEndTs) displayEndTs = hardStopEndTs;
        else if (days === 1) displayEndTs = displayStartTs + (24 * 60 * 60 * 1000);
        else displayEndTs = Infinity;

        let displayTimestamps = sortedTimestamps.filter(ts => {
            if (ts < displayStartTs || ts > displayEndTs) return false;
            if (days === 1 && !isCrypto) {
                const tsDate = new Date(ts);
                const hour = tsDate.getHours();
                const hasDataAfter8am = sortedTimestamps.some(t => {
                    const d = new Date(t);
                    return d.getHours() >= 8 && t >= displayStartTs && t <= displayEndTs;
                });
                if (hasDataAfter8am && hour < 8) return false;
            }
            return true;
        });

        const lastKnownPrices = new Map();
        const allTsBefore = sortedTimestamps.filter(ts => ts < displayStartTs);
        const lastTsOverall = allTsBefore.length > 0 ? allTsBefore[allTsBefore.length - 1] : null;

        if (lastTsOverall !== null) {
            for (const t of tickers) {
                const hist = historicalDataMap.get(t);
                let price = findClosestPrice(hist, lastTsOverall, '1wk');
                if (price === null) {
                    const tickerTimestamps = Object.keys(hist).map(Number).filter(ts => ts < displayStartTs);
                    if (tickerTimestamps.length > 0) {
                        const lastTickerTs = tickerTimestamps[tickerTimestamps.length - 1];
                        price = findClosestPrice(hist, lastTickerTs, '1wk');
                    }
                }
                if (price !== null) lastKnownPrices.set(t, price);
            }
        }

        // Backfill
        for (const t of tickers) {
            if (!lastKnownPrices.has(t)) {
                const hist = historicalDataMap.get(t);
                if (hist) {
                    const timestamps = Object.keys(hist).map(Number).sort((a, b) => a - b);
                    if (timestamps.length > 0) {
                        const firstPrice = hist[timestamps[0]];
                        if (firstPrice !== null && firstPrice > 0) {
                            lastKnownPrices.set(t, firstPrice);
                        }
                    }
                }
            }
        }

        // Forward Fill Init for 1D (Actions)
        if (days === 1) {
            const today = new Date(displayStartUTC);
            today.setHours(0, 0, 0, 0);
            let lastTradingDay = getLastTradingDay(today);
            lastTradingDay.setHours(23, 59, 59, 999);
            const lastTradingDayTs = lastTradingDay.getTime();

            for (const t of tickers) {
                if (!lastKnownPrices.has(t)) {
                    const hist = historicalDataMap.get(t);
                    if (hist && Object.keys(hist).length > 0) {
                        const histArray = Object.keys(hist)
                            .map(ts => ({ timestamp: parseInt(ts), price: hist[ts] }))
                            .filter(p => p.price !== null && p.timestamp <= lastTradingDayTs)
                            .sort((a, b) => a.timestamp - b.timestamp);

                        if (histArray.length > 0) {
                            const closingPrice = histArray[histArray.length - 1].price;
                            lastKnownPrices.set(t, closingPrice);
                        }
                    }
                }
            }
        }

        let previousTotalValue = 0;
        let currentTWR = 1.0;

        for (let i = 0; i < displayTimestamps.length; i++) {
            const ts = displayTimestamps[i];
            let tsChangedInvested = false;
            const prevTs = (i === 0) ? displayStartUTC.getTime() - 1 : displayTimestamps[i - 1];
            let cashFlow = 0;

            for (const [t, buyList] of assetMap.entries()) {
                for (const buy of buyList) {
                    if (buy.date.getTime() > prevTs && buy.date.getTime() <= ts) {
                        assetQuantities.set(t, assetQuantities.get(t) + buy.quantity);
                        const flow = buy.price * buy.quantity;
                        assetInvested.set(t, assetInvested.get(t) + flow);
                        cashFlow += flow;
                        tsChangedInvested = true;
                    }
                }
            }

            let currentTsTotalValue = 0;
            let totalInvested = 0;
            let hasAtLeastOnePrice = false;
            let currentTsUnitPrice = null;

            for (const t of tickers) {
                const hist = historicalDataMap.get(t);
                const qty = assetQuantities.get(t);

                if (qty > 0) {
                    let price = null;
                    // Support CASH/Liquidité
                    if (t === 'CASH' || t === 'EUR') {
                        price = 1.0;
                    } else if (hist && hist[ts]) {
                        price = hist[ts];
                    } else {
                        if (lastKnownPrices.has(t)) price = lastKnownPrices.get(t);
                    }

                    if (price !== null) {
                        currentTsTotalValue += price * qty;
                        hasAtLeastOnePrice = true;
                        lastKnownPrices.set(t, price);
                        if (isSingleAsset) currentTsUnitPrice = price;
                    }
                }
                const investedAmount = assetInvested.get(t);
                totalInvested += investedAmount;
            }

            // CALCUL MODE RENTABILITÉ (ROI) pour cohérence Dashboard
            // Au lieu du TWR, on calcule (Valeur - Investi) / Investi
            // Cela assure que le dernier point correspond au KPI "Total Return"
            if (totalInvested > 0) {
                currentTWR = (currentTsTotalValue - totalInvested) / totalInvested;
                // On ajoute +1 pour matcher l'échelle de base 1.0 du graphique TWR précédent (ou on adapte)
                // Le chart attendait un facteur (ex: 1.10 pour +10%). 
                // ROI est 0.10. Donc TWR = 1 + ROI.
                currentTWR += 1.0;
            } else {
                currentTWR = 1.0;
            }

            twr.push(currentTWR);
            previousTotalValue = currentTsTotalValue;

            const label = labelFormatFunc(ts);
            labels.push(label);

            if (hasAtLeastOnePrice || tsChangedInvested) {
                invested.push(totalInvested);
                values.push(currentTsTotalValue);
                if (isSingleAsset) unitPrices.push(currentTsUnitPrice);
            } else {
                invested.push(null);
                values.push(null);
                if (isSingleAsset) unitPrices.push(null);
            }
        }

        if (isSingleAsset) {
            const buyList = assetMap.get(ticker);
            const finalEndTs = (displayEndTs === Infinity ? todayUTC.getTime() : displayEndTs);
            let maxToleranceMs = (days === 1) ? 2 * 3600000 : 4 * 86400000;

            for (const buy of buyList) {
                const buyTs = buy.date.getTime();
                if (buyTs >= displayStartTs && buyTs <= finalEndTs) {
                    let closestIdx = -1;
                    let minDiff = Infinity;
                    for (let i = 0; i < displayTimestamps.length; i++) {
                        const diff = Math.abs(displayTimestamps[i] - buyTs);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    if (closestIdx !== -1 && minDiff <= maxToleranceMs) {
                        const rate = buy.currency === 'USD' ? dynamicRate : 1;
                        purchasePoints.push({
                            x: labels[closestIdx],
                            y: buy.price * rate,
                            quantity: buy.quantity,
                            date: buy.date
                        });
                    }
                }
            }
        }

        console.log(`[Return] yesterdayClose = ${yesterdayClose ? yesterdayClose.toFixed(2) : 'null'}`);

        return {
            labels,
            invested,
            values,
            yesterdayClose,
            yesterdayUnitPrice,
            unitPrices,
            purchasePoints,
            timestamps: displayTimestamps,
            twr,
            historicalDataMap
        };
    }
}
